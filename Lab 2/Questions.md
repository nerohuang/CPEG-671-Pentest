# Lab 2 – Manual Decompilation

## Problems:
1. What gcc command flags would you use to produce an assembly listing in 32-bit mode using the intel style assembly syntax?
    
    gcc -S -masm=intel -m32 lab2-x.c

2. Suppose you wrote a program in C that declared and initialized variable a with value 42 and variable b with value 52. The program then returned the sum of these two values. How would the assembly listing differ if compiled with optimization and without optimization?

    By running command:

    gcc -O0 test.c -o test -S -masm=intel -m32 and

    gcc -O3 test.c -o test -S -masm=intel -m32

    I get two assembly code:

    for without optimization one, it will use add to calculate and store the ans to eax;

    for optimization one, it will directly store the answer 94 to register.

3. For lab2-1.s, what does the first SUB instruction do? What purpose does this serve?

    It used to subtract in arbitrary value from the stack pointer and creating empty 
    space on the stack, and here it create 16 bytes for variable.

4. For lab2-2.s, how many local variables exist? How do you know this?

    There are two local variables exist.

    From line:

    mov DWORD PTR [ebp-8], 10

    mov DWORD PTR [ebp-4], 14

    We can get there two registers holding two value 10 and 14.

5. For lab2-3.s, draw a diagram of the stack prior to execution of line 32 – there should be 3 stack frames – show the beginning and end of each frame as well as the current positions of EBP and ESP.

    The answer is at the picture I upload.

6. For lab2-4.s, line 33 can be replaced with a (arguably) simpler instruction – what is the instruction that could replace it? Does this new instruction take up more or less room in the executable?

    It can change to 

    INC DWORD PTR [ebp-12]

    INC will not change CF but ADD will, t woas the key point.
    INC will take less room than ADD but it will take more time.